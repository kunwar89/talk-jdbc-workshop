= Spring Data JDBC Workshop
:icons: font
:linkattrs:

include::variables.ad[]

== What is Spring Data?

Spring Data offers APIs for persisting data to various data stores.
Some examples are MongoDB, Neo4J, Elastic Search, Relational Databases using JPA or JDBC and many more.

The API is inspired by Domain Driven Design and comes in most cases with two levels:

1. The Repository abstraction.
A `Repository` looks somewhat like a collection of all instances of a given type with methods to add, find and delete instances.
Repository can be extended in various ways many of which just require defining additional methods to a `Repository` without actually implementing them.
The implementation will be provided by Spring Data.

2. The Template abstraction.
A template is a class that allows more direct access to special features of the underlying persistence technology.

Spring Data does not try to unify the access to all these stores in order to make them interchangeable.
Such an endeavor is bound to fail since each an every persistence store has features that are impossible or very expensive to emulate in another.
A unifying API would either need to provide such an emulation or not offer any of these features at all.

Instead Spring Data tries to provide a consistent API that makes it easy for users of one Spring Data variant to learn another while encouraging good application design at the same time.

==  First Spring Data JDBC example

=== Create a Spring Starter Project

With Spring Tools and IntelliJ you can do this directly in the IDE.
This only describes the web based variant.

1. Goto https://start.spring.io

2. Select
    * latest Milestone version of Spring Boot ({spring.boot.version})
    * add HyperSQL Database
    * add Lombok
    * add JDBC API
    * generate the project
    * unpack
    * open in the IDE

Some Notes on the dependencies:

**Lombok** isn't really needed but it makes the code nice and concise.
If you don't like Lombok you can create constructors, `equals` and `hashcode` implementations with your IDE just as well.

**JDBC API** is actually not what we need. But it's close and we'll change it in a moment.

=== Add Spring Data JDBC

Open the `pom.xml`.
Find the following section:

```
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
```

And replace it with this one.

```
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jdbc</artifactId>
		</dependency>
```
=== Build everything

From the commandline run

```
./mvnw clean install
```

Or run the `DemoApplication` to make sure everything works and can be downloaded.

=== Create an entity and a repository

Create an entity.

```
import org.springframework.data.annotation.Id;

@ToString
@EqualsAndHashCode
public class Speaker {
	@Id
	Long id;
	String name;
}
```

Create a repository

```
import org.springframework.data.repository.CrudRepository;

public interface SpeakerRepository extends CrudRepository<Speaker, Long> { }

```

And check that you can inject it, for example by changing the DemoApplication as follows:

```
@SpringBootApplication
public class DemoApplication implements CommandLineRunner {

	@Autowired
	SpeakerRepository speakers;

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}


	@Override
	public void run(String... args) {
		if (speakers != null) {
			System.out.println("I'm running and have a speakers repository");
		} else {
			System.out.println("drats, something is wrong");
		}
	}
}
```

We implement the `CommandLineRunner` interface in order to execute some code at start up.
Add an `@Autowired` field of type `SpeakerRepository` and check that it is not `null`.

=== Actually Use the Repository.

Add the following to the `run` method in order to create a Speaker and persist it:

```
Speaker martin = new Speaker();
martin.name = "Martin Fowler";

Speaker saved = speakers.save(martin);

System.out.println(saved);
```

If you execute the changed application you'll get an exception like the following:

```
user lacks privilege or object not found: SPEAKER in statement [INSERT INTO speaker (name) VALUES (?)]
```
This is because we didn't create any tables yet!

Add the following `schema.sql` to the `source/main/resources` folder to fix this.

```
CREATE TABLE SPEAKER
(
  ID   BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1) PRIMARY KEY,
  NAME VARCHAR(200)
);
```

=== Add some Logging

In order to better understand what is going on we should add some logging.
Add the following line to your `application.properties` file.

```
logging.level.org.springframework.jdbc.core=TRACE
```

All execution of SQL statements happen through Springs `JdbcTemplate` so it's logging facility may be used for gaining insights what statements get executed.

=== Move our Experiments to a Test.

Moving our experiments to a test makes it easier to ... well ... test stuff.
Create a class like the following an run it in your IDE.

```
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.jdbc.DataJdbcTest;
import org.springframework.test.context.junit4.SpringRunner;

import static org.assertj.core.api.Assertions.*;

@RunWith(SpringRunner.class)
@DataJdbcTest
public class SpeakerRepositoryTests {

	@Autowired
	SpeakerRepository speakers;

	@Test
	public void saveInstance() {

		Speaker martin = new Speaker();
		martin.name = "Martin Fowler";

		Speaker saved = speakers.save(martin);

		assertThat(saved.id).isNotNull();
	}
}
```

Make sure to remove the save operation in the `CommandLineRunner`.
Otherwise it will run before each test and mess with your test data.

=== Wrap up of the first example

In order to use Spring Data JDBC in a Spring Boot application you need to do the following:

* add `spring-boot-starter-data-jdbc` to your dependencies.

* create entities.

* create repositories.

* inject the latter where needed.

* persist away.

== Spring Data JDBC vs Spring Data JPA

Why are there two Spring Data modules for the same underlying technology: Relational databases?

JPA is pretty much the default technology when accessing RDBMSes on the JVM.
This does not mean it is without problems.

* It considers the complete domain object graph a single graph.
So you might load a few instances with a query and then navigate the whole database using objects.
While this is possible it is very inefficient.
Either you rely on lazy loading which means the required data is loaded piece by piece.
Also a simple call of an getter might trigger an arbitrary amount of SQL statements.
Or you rely on eager loading which leads to large amounts of data loaded even if not needed.

* Similar to lazy loading JPA uses write behind to dynamically determine when to write back to the database.
This can lead to confusing scenarios where the user thinks data is stored in the database but it actually isn't.

* JPA employs an first level cache that guarantees that for a given class and id only a single instance will get loaded into a persistence context.
In 99% of the cases this is rather nice.
But in 1% of the cases this is really confusing.
For example you can't easily load the current state of an object from the database if you already loaded it before.

* Finally JPA maintains a relationship between domain objects and the persistence context.
This is to enable dirty checking.
Again, often this is very useful.
But  it also can get very confusing when you actually don't want to persist changes to an entity.
Or if you want to copy an entity.

This makes JPA hard to understand and hard to use correctly.

Spring Data JDBC tries to be a conceptually simpler alternative.
We achieve that by not doing many things.

1. No Lazy Loading.
2. No write behind cache.
3. No cache at all. Of course you are free to add a cache on top of it.
4. No proxies.

Spring Data will save you data when you call `save` and only return once it is inserted or updated in the database.
It will not save data you haven't invoked `save` for.
All data will be fully loaded within the method call that loads the data.

Try the following examples.
Also inspect the logs to see what kind of interaction is happening with the database.

```
Speaker martin = new Speaker();
martin.name = "Martin Fowler";
Speaker saved = speakers.save(martin);
assertThat(saved.id).isNotNull();


saved.id = null;

Speaker savedAgain = speakers.save(martin);

assertThat(savedAgain.id).isNotNull();

assertThat(speakers.findAll()).hasSize(2);
```

```
Speaker martin = new Speaker();
martin.name = "Martin Fowler";
Speaker saved = speakers.save(martin);
assertThat(saved.id).isNotNull();

Optional<Speaker> loaded = speakers.findById(saved.id);
Optional<Speaker> reloaded = speakers.findById(saved.id);

assertThat(loaded.get())
		.isEqualTo(reloaded.get())
		.isNotSameAs(reloaded.get());
```

While this  makes things simpler it brings some extra challenges.
We'll see those later and how to tackle them.

== Storing Relationships

Let's make `Speakers` more interesting.
Each speaker should have a `Map` of `Website` references.
Like so:

```
@EqualsAndHashCode
@ToString
@AllArgsConstructor
public class Website {

	String link;
	String title;
}
```

Add the following line to the `Speaker` class.

```
Map<String, Website> websites = new HashMap<>();
```

Of course we need adapt our schema as well.
Add the following to the `schema.sql` file.

```
CREATE TABLE WEBSITE
(
  SPEAKER     BIGINT,
  SPEAKER_KEY VARCHAR(20),
  LINK        VARCHAR(200),
  TITLE       VARCHAR(200),
  PRIMARY KEY (SPEAKER, SPEAKER_KEY)
);
```

Note that the table has two extra columns.
One for a backreference to `SPEAKER` and one for the map key.

Create a test to play around with `Speaker` and `Website`.

For example.

```
Speaker martin = new Speaker();
martin.name = "Martin Fowler";
martin.websites.put("main", new Website("https://martinfowler.com/", "Martin Fowler"));
martin.websites.put("wikipedia", new Website("https://en.wikipedia.org/wiki/Martin_Fowler", "Martin Fowler - Wikipedia"));

Speaker saved = speakers.save(martin);
assertThat(saved.id).isNotNull();

Speaker reloaded = speakers.findById(saved.id).get();

reloaded.websites.get("wikipedia").title = "Martin Fowler on Wikipedia";

speakers.save(reloaded);

speakers.delete(reloaded);

```

Take a look at the SQL used.
Do you have questions?

== Aggregates in DDD and M:x Relationships Spring Data JDBC


== Id Generation
== Supported Data Types
== Custom Conversions
== Embeddable
== @Query Annotation
== Custom Methods
== Integration in Spring Data Rest
== Q&A

include::self.ad[]
